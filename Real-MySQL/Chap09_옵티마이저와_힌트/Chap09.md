# 09 옵티마이저와 힌트
옵티마이저
* 최적의 실행 계획을 수립하는 작업을 수행

## 9.1 개요
### 9.1.1 쿼리 실행 절차
MySQL에서 쿼리가 실행되는 과정
1. SQL 파싱(Parsing) - MySQL 엔진
   * 요청된 SQL 문장을 쪼개 MySQL 서버가 이해할 수 있는 수준으로 분리
   * SQL 파서라는 모듈로 처리
   * 문법적으로 잘못되었다면 여기서 걸러짐
   * SQL 파스 트리 생성
2. 최적화 및 실행 계획 수립 - MySQL 엔진
   * MySQL 서버의 옵티마이저가 처리
   * SQL 파스 트리를 찾모하며 다음 내용 처리
     * 불필요한 조건 제거 및 복잡한 연산의 단순화
     * 조인 관계의 테이블을 읽을 순서 결정
     * 사용할 인덱스 결정
     * 가져온 레코드를 재가공 필요 여부 결정
   * 이 단계가 완료되면 실행 계획이 만들어짐
3. 수립된 실행 계획 처리 - MySQL 엔진 + 스토리지 엔진
   * 스토리지 엔진에 레코드 읽기 요청
   * MySQL 엔진에서 스토리지 엔진에서 받은 레코드를 조인, 정렬 작업 수행

### 9.1.2 옵티마이저의 종류

규칙 기반 최적화(Rule-based optimizer, RBO)
* 초기 버전 오라클에서 채택
* 통계 정보를 고려하지 않고 옵티마이저의 우선순위에 따라 실행 계획을 수립
  * 같은 쿼리에 대해서는 거의 항상 같은 실행 방법
* 사용자의 데이터는 분포도가 다양하기 때문에 많은 DBMS에서는 사용하지 않는다.

비용 기반 최적화(Cost-based optimizer, CBO)
* 현재 대부분의 DBMS에서 채택
* 쿼리를 처리하기 위한 여러 가지 방법을 만들고 각 단위 작업의 비용을 산출하여 비용이 최소로 소요되는 처리 방식을 선택하여 실행

## 9.2 기본 데이터 처리
### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

MySQL 옵티마이저가 풀 테이블 스캔을 선택하는 조건
* 레코드 건수가 너무 작아 인덱스를 통해 읽는 것보다 빠른 경우
  * 일반적으로 테이블이 페이지 1개로 구성된 경우
* WHERE 절이나 ON 절에 인덱스를 이용할 조건이 없는 경우
* 인덱스 레인지 스캔이더라도 일치 레코드 건수가 너무 많은 경우

InnoDB에서의 풀 테이블 스캔
* 디스크로부터 페이지를 하나씩 읽지 않는다.
* 연속된 데이터 페이지가 읽히면 한번에 4개~8개의 페이지를 읽으면서 계속 그 수를 증가시킨다.
* 미리 버퍼풀에 데이터를 준비시키므로 쿼리가 상당히 빨리 처리될 수 있다.
  * 리드 어헤드 : 어떤 영역의 데이터가 필요해질 것을 예측해서 미리 버퍼 풀에 가져다두는 것

리드 어헤드는 풀 인덱스 스캔에서도 동일하게 사용된다.

이 쿼리는 어떻게 처리될까?
~~~sql
mysql> SELECT COUNT(*) FROM employees;
~~~
* 풀 인덱스 스캔을 할 가능성이 높다.
* 단순히 레코드의 건수만 필요로 하는 쿼리라면 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 횟수를 줄일 수 있으므로
* 칼럼이 필요한 쿼리의 경우 풀 테이블 스캔을 수행한다.

### 9.2.2 병렬 처리
MySQL 8.0 버전에서는 아무런 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리 가능
~~~sql
mysql> SET SESSION innodb_parallel_read_threads=4;
mysql> SELECT COUNT(*) FROM slaries;
~~~

### 9.2.3 ORDER BY 처리
정렬을 처리하는 방법은 두 가지

![09-01](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/6cae5d08-390d-4f4a-9814-f30c761348e3)

모든 정렬을 인덱스를 이용하도록 튜닝이 불가능한 이유
* 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 이유
* GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 이유
* UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 이유
* 랜덤하게 결과 레코드를 가져와야 하는 경우

MySQL에서 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지 확인하는 방법
* 실행 계획의 Extra 칼럼에 "Using filesort" 메시지가 표시되는지 여부로 판단

### 9.2.3.1 소트 버퍼
정렬을 수행하기 위해 할당 받은 별도의 메모리 공간
* 쿼리의 실행이 완료되면 즉시 반납된다.

정렬이 문제가 되는 부분
* 정렬 대상 레코드가 메모리에 할당된 소트 버퍼만으로 정렬할 수 있다면 아주 빠르게 완료
* 그런데 소트 버퍼로 할당된 공간보다 크다면?
  * 정렬 대상 레코드를 여러 조각으로 나눠서 처리
  * 임시 저장을 위해 디스크를 사용

소트 버퍼가 모자른 경우 동작 과정 - 멀티 머지(Multi-merge)
1. 메모리의 소트 버퍼에서 정렬을 수행하고 결과를 임시로 디스크에 기록
2. 다음 레코드를 가져와 정렬하고 디스크에 임시 저장 - 반복
3. 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행

작업들은 모두 디스크 쓰기 읽기를 유발하며 레코드 건수가 많을수록 작업이 늘어난다.


### 9.2.3.2 정렬 알고리즘

싱글 패스 정렬 방식
* 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식

~~~sql
mysql> SELECT emp_no, first_name, last_name
        FROM employees
        ORDER BY first_name;
~~~

위 쿼리를 싱글 패스 정렬 방식으로 처리하는 절차

![09-02](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/2fd1950b-2f21-48a2-82ff-21083a5b9f18)
* 정렬에 필요하지 않은 last_name 컬럼까지 읽어 소트 버퍼에 담고 정렬을 수행한다.

투 패스 정렬 방식
* 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행
* 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬 방식

싱글 패스 방식 도입 이전부터 사용하던 방식
* MySQL8.0에서도 특정 조건에서는 투 패스 정렬 방식을 사용

위 쿼리를 투 패스 정렬 방식으로 처리하는 절차

![09-03](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/df067da3-e0fc-4006-ac99-33f61f1b7a24)
* 테이블을 두 번 읽어야 하므로 불합리하다.

최신 버전에서는 대부분은 싱글 패스 정렬 방식을 사용한다.
* 단 다음의 조건에서는 투 패스 정렬 방식을 사용한다.
    1. 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
    2. BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함될 때

성능 비교
* 싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능
* 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 많은 경우 빠른 성능


### 9.2.3.3 정렬 처리 방법

쿼리에 ORDER BY가 사용되면 반드시 다음 3가지 처리 방법 중 하나로 처리
* 아래로 갈수록 처리 속도는 떨어짐

![09-04](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/0a7c30b2-8caa-4014-927f-425e3cea78c0)


인덱스를 사용할 수 없는 경우 - Filesort
* 이때 MySQL 옵티마이저는 다음 2가지 방법 중 하나를 선택
  * 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
  * 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행


### 인덱스를 이용한 정렬
* 반드시 ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블에 속하고
* ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.
* WHERE절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.
* B-Tree 계열의 인덱스에서만 사용할 수 있다.
* 여러 테이블이 조인되는 경우 네스티드-루프 방식의 조인에서만 사용 가능


### 조인의 드라이빙 테이블만 정렬
* 조인을 실행하기 전 첫 번째 테이블의 레코드를 먼저 정렬하고 다음 조인을 실행
* 조인에서 첫 번째로 읽히는 테이블의 칼럼만으로 ORDER BY 절을 작성해야 한다.

예제
~~~sql
mysql> SELECT *
    FROM employees e, salaries s
    WHERE s.emp_no=e.emp_no;
        AND e.emp_no BETWEEN 100002 AND 100010
    ORDER BY e.last_name;
~~~

아래의 조건으로 옵티마이저는 employees 테이블을 드라이빙 테이블로 선택한다.
* WHERE 절의 검색 조건은 employees 테이블의 프라이머리 키를 이용해 검색하면 작업량을 줄일 수 있다.
* 드리븐 테이블의 조인 칼럼인 emp_no 칼럼에 인덱스가 있다.


조인의 첫 번째 테이블만 정렬 실행하는 과정

![09-05](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/46c24fec-bb90-4bbc-aa97-e62894faf2cf)
1. 인덱스를 이용해 "emp_no BETWEEN 10002 AND 100010" 조건을 만족하는 9건을 탐색
2. 검색 결과를 last_name 칼럼으로 정렬을 수행(Filesort)
3. 정렬된 결과를 순서대로 읽으면서 salaries 테이블과 조인을 수행해 86건의 최종 결과를 가져옴

### 임시 테이블을 이용한 정렬
2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다.
* 이 방법은 정렬해야 할 레코드 건수가 가장 많기 때문에 가장 느린 정렬 방법이다.

예제
~~~sql
mysql> SELECT *
        FROM employees e, salaries s
        WHERE s.emp_no=e.emp_no
            AND e.emp_no BETWEEN 100002 AND 100010
        ORDER BY s.salary;
~~~
* ORDER BY의 정렬 기준 칼럼이 드라이빙 테이블이 아닌 드리븐 테이블에 있는 칼럼
* 즉, 정렬이 수행되기 전 salaries 테이블을 읽어야 하므로 이 쿼리는 조인된 데이터를 가지고 정렬할 수밖에 없다.

이 쿼리의 실행 계획

![09-06](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/3a182c56-8c02-4712-88e5-58340d781041)
* Extra 칼럼의 "Using temporary; Using filesort"라는 코멘트 표시
  * 이는 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬 처리했음을 의미

이 쿼리의 실행 절차

![09-07](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/7833c221-1df9-492b-aab5-3ecf68a6f1d5)


### 정렬 처리 방법의 성능 비교
LIMIT
* 테이블이나 처리 결과의 일부만 가져오기 때문에 작업량을 줄이는 역할
* 그런데 ORDER BY나 GROUP BY 같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수만큼만 가져와서는 처리할 수 없다.
* 우선 조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그루핑 작업을 실행해야만 비로소 LIMIT 건수를 제한할 수 있다.
* WHERE 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 자주 발생한다.

인덱스를 사용하지 못하는 정렬이나 그루핑 작업이 왜 느리게 작동할 수밖에 없는지 한번 살펴보자.

이를 위해 쿼리가 처리되는 방법을 두 가지로 구분해보자.

### 스트리밍 방식
* 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식을 의미
* 스트리밍 방식으로 쿼리가 처리된다면 MySQL 서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터의 가공 작업을 시작할 수 있다.
* 스트리밍 방식으로 처리되는 쿼리는 빠른 응답 시간을 보장해준다.

LIMIT 처럼 결과 건수를 제한 하는 조건들은 쿼리의 실행 시간을 상당히 줄일 수 있다.


### 버퍼링 방식
* ORDER BY나 GROUP BY 같은 처리는 스트리밍되는 것을 불가능하게 한다.
* 우선 WHERE 조건에 일치하는 모든 레코드를 가져온 후 정렬하거나 그루핑해서 차례대로 보내야 하기 때문이다.
* MySQL 서버에서 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 대기해야 하므로 응답 속도가 느려진다.

정렬 처리 방법 중
* 스트리밍 방식 : 인덱스
* 버퍼링 방식 : 나머지

### 정렬 관련 상태 변수
정렬 관련 상태 변수를 확인할 수 있다.
* 몇 건의 레코드나 정렬 처리를 수행했는지
* 소트 버퍼 간 병합 작업은 몇 번이나 발생했는지

정렬 관련 상태 변수를 확인하는 명령
~~~sql
mysql> FLUSH STATUS;
mysql> SHOW STATUS LIKE 'Sort%';
~~~

위 명령으로 나오는 값들
* Sort_merge_passes : 멀티 머지 처리 횟수
* Sort_range : 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
* Sort_scan : 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
* Sort_rows : 지금까지 정렬한 전체 레코드 건수

### 9.2.4 GROUP BY 처리
GROUP BY
* 쿼리가 스트리밍 된 처리를 할 수 없게 하는 처리 중 하나
* HAVING 절을 함께 사용
  * 필터링 역할을 수행
* GROUP BY에 사용된 조건은 인덱스를 사용하여 처리 불가
  * HAVING을 튜닝하려고 인덱스를 생성하거나 다른 방법을 고민할 필요는 없다.

GROUP BY 작업에서 인덱스를 사용하는 경우
* 인덱스 스캔 방법 : 차례로 읽는
* 루스 인덱스 스캔 방법 : 건너뛰며 읽는

인덱스를 사용하지 않는 경우
* 임시 테이블을 사용

### 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
ORDER BY와 마찬가지로
* 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 GROUP BY 칼럼으로 이미 인덱스가 있다면
* 그 인덱스를 차례대로 읽으며 그루핑 작업을 수행, 그 결과로 조인을 처리

GROUP BY가 인덱스를 사용해서 처리된다 해도 임시 테이블이 필요할 떄도 있다.
* 그룹 함수 등의 그룹값을 처리해야하는 경우

GROUP BY가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽는 것
* 쿼리 실행 시점에 추가적인 정렬 작업이나 내부 임시 테이블은 필요하지 않다.

이런 그루핑 방식을 사용하는 쿼리의 실행 계획에는
* Extra 칼럼에 별로 GROUP BY 코멘트나 임시 테이블 사용, 정렬 관련 코멘트가 표시되지 않음

### 루스 인덱스 스캔을 이용하는 GROUP BY
루스 인덱스 스캔 방식이란
* 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미
* 옵티마이저기 루스 인덱스 스캔을 사용하면 실행계획
  * Extra 칼럼에 "Using index for group-by" 코멘트가 표시된다.

루스 인덱스 스캔을 사용하는 예시
~~~sql
mysql> EXPLAIN
        SELECT emp_no
        FROM salaries
        WHERE from_data='1985-03-01'
        GROUP BY emp_no;
~~~
* salaries 테이블의 인덱스는 (emp_no, from_data)로 생성되어 있으므로 위 WHERE 조건은 인덱스 레인지 스캔이 불가능
* 하지만 실행 계획을 살펴보면 인덱스 레인지 스캔을 이용했으며
* Extra 칼럼을 확인하면 GROUP BY 처리까지 인덱스를 사용했음을 알 수 있다.

MySQL 서버가 이 쿼리를 처리하는 순서
1. (emp_no, from_data) 인덱스를 차례대로 스캔하며 emp_no의 값 "10001"을 찾아낸다.
2. 찾은 것 중 from_data 값이 '1985-03-01'인 레코드만 가져온다.
3. (emp_no, from_data) 인덱스에서 emp_no의 그 다음 유니크한 값을 가져온다.
4. 3번 단계에서 결과가 없으면 처리 종료, 있다면 2번으로 돌아가 반복 수행

MySQL에서 루스 인덱스 스캔
* 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용 가능
* 프리픽스 인덱스(칼럼의 앞쪽 값으로만 생성된 인덱스)에는 사용 불가
* 유니크한 값의 수가 적을수록 성능이 향상
  * 분포도가 좋지 않은 인덱스일수록 더 빠른 결과
  * 임시테이블이 필요하지 않음

루스 인덱스 스캔을 사용할 수 없는 쿼리
* MIN, MAX 외의 집합 함수(SUM 등)가 사용된 경우
* GROUP BY에 사용된 칼럼이 인덱스 구성 칼럼의 왼쪽부터 일치하지 않은 경우
* SELECT 절의 칼럼이 GROUP BY와 일치하지 않는 경우

### 임시 테이블을 사용하는 GROUP BY
인덱스를 전혀 사용하지 못할 때 이 방식으로 처리

예제 쿼리
~~~sql
mysql> EXPLAIN
        SELECT e.last_name, AVG(s.salary)
        FROM employees e, salaries s
        WHERE s.emp_no=e.emp_no
        GROUP BY e.last_name;
~~~

쿼리의 실행계획
* Extar 칼럼에 "Using temporary" 표시
* 인덱스를 전혀 사용할 수 없는 GROUP BY이기 때문
* 그런데 "Using filesort"는 표시되지 않았다.
  * MySQL 8.0 이전 버전까지는 GROUP BY가 사용되는 경우 그루핑 되는 칼럼으로 묵시적인 정렬을 시행
  * MySQL 8.0 이후 버전에서는 ORDER BY가 없는 경우 묵시적인 정렬을 수행하지 않음
  * ORDER BY가 사용된 경우 Using filesort 메시지도 함께 표시된다.


### 9.2.5 DISTINCT 처리
DISTINCT
* 특정 칼럼의 유니크한 값만 조회하려면 SELECT 쿼리에 DISTINCT를 사용
* 집합 함수의 사용 여부로 구분할 수 있다.
  * 각 경우에 키워드가 영향을 미치는 범위가 달라진다.
* 집합 함수가 사용되는 경우 DISTINCT 처리가 인덱스를 사용하지 못하면 임시 테이블을 항상 사용
  * 그러나 실행 계획의 Extra 칼럼에는 Using temporary 메시지가 출력되지 않는다.

### SELECT DISTINCT ...
SELECT DISTINCT
* SELECT 되는 레코드 중 유니크한 레코드만 가져올 때 사용
* GROUP BY와 동일한 방식으로 처리

다음 쿼리는 내부적으로 동일하게 처리된다.
~~~sql
mysql> SELECT DISTINCT emp_no FROM salaries;
mysql> SELECT emp_no FROM salaries GROUP BY emp_no;
~~~


DISTINCT를 사용할 때 주의사항
* 레코드(튜플)를 유니크하게 SELECT 하는 것, 특정 칼럼만 유니크하게 조회하는 것이 아님

~~~sql
mysql> SELECT DISTINCT first_name, last_name FROM employees;
mysql> SELECT DISTINCT(first_name), last_name FROM employees;
~~~
* 두 쿼리 모두 (first_name, last_name) 조합에서 유니크한 레코드를 가져오는 것
* DISTINCT 키워드는 조회되는 모든 칼럼에 영향을 미친다.

### 집합 함수와 함께 사용된 DISTINCT
집합 함수 내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들을 가져온다.

~~~sql
mysql> EXPLAIN SELECT COUNT(DISTINCT s.salary)
        FROM employees e, salaries s
        WHERE e.emp_no=s.emp_no
        AND e.emp_no BETWEEN 10001 AND 100100;
~~~
* 이 쿼리는 내부적으로 COUNT(DISTINCT s.salary)를 처리하기 위해 임시 테이블을 사용
* 그러나 실행 계획에서 임시 테이블을 사용한다는 메시지를 보여주지는 않음
* 만약 인덱스된 칼럼에 대해 DISTINCT 처리를 수행할 때는 임시 테이블 없이 처리를 수행할 수 있다.

### 9.2.6 내부 임시 테이블 활용
내부적인 임시 테이블(Internal temporary table)
* MySQL 엔진이 스토리지 엔진으로 받은 레코드를 정렬하거나 그루핑할 때 사용
* 내부적이라는 단어가 사용된 이유 : CREATE TEMPORARY TABLE 명령으로 만든 임시 테이블과는 다르기 때문
* 메모리에 생성되었다가 크기가 커지면 디스크로 옮겨진다.
* 쿼리가 완료되면 자동 삭제

### 메모리 임시 테이블과 디스크 임시 테이블
MySQL 8.0 이전 버전 - MEMORY 스토리지 엔진 사용
* 가변 길이 타입 제공 불가 - 최대 메모리 할당(낭비)
* 디스크에 임시 테이블이 만들어질 때 사용되는 MyISAM 엔진은 트랜잭션을 지원하지 않는다.

MySQL 8.0 이후 버전 - TempTable 스토리지 엔진
* 가변 길이 타입 지원
* 트랜잭션 지원하는 InnoDB 스토리지 엔진 사용

internal_tmp_mem_storage_engine 시스템 변수
* MEMORY와 TempTable 중 선택 가능
* 기본값 TempTable

temptable_max_ram 시스템 변수
* TempTable이 최대한 사용 가능한 메모리 공간의 크기를 제어 가능
* 기본값은 1GB, 이 값보다 커지는 경우 임시 테이블을 디스크로 기록
* 이 때 2가지의 디스크 저장 방식 중 하나를 선택
  * MMAP 파일로 디스크에 기록
    * InnoDB에 비해 오버헤드가 적다
    * tmpdir 시스템 변수에 정의된 디렉터리에 저장
  * InnoDB 테이블로 기록
  * temptable_use_mmap 시스템 변수로 설정 가능

internal_tmp_disk_storage_engine 시스템 변수
* 임시 테이블이 메모리에 생성되지 않고 처음부터 디스크 테이블로 생성되는 경우 사용할 스토리지 엔진 등록
* 기본값 InnoDB

### 임시 테이블이 필요한 쿼리
임시 테이블이 필요한 쿼리의 종류
* ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
* ORDER BY와 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
* DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
* UNION이나 UNION DISTINCT가 사용된 쿼리
* 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리

임시 테이블 사용 여부 확인 방법
* 실행 계획의 Extra 칼럼의 Using temporary 메시지 표시 여부 확인
* 표시되지 않아도 마지막 3개 패턴은 임시 테이블을 사용
* 1~4번 쿼리 패턴은 유니크 인덱스가 있는 내부 임시 테이블 생성
  * 조금 더 느리다.
* 마지막 패턴은 유니크 인덱스가 없는 내부 임시 테이블 생성

### 임시 테이블이 디스크에 생성되는 경우
* UNION이나 UNION ALL에서 SELECT 되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
* GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
* 메모리 임시 테이블의 크기가 tmp_table_size 또는 max_heap_table_size 시스템 변수보다 크거나 temptable_max_ram 시스템 변수보다 큰 경우

### 임시 테이블 관련 상태 변수
실행 계획에서 Using temporary가 표시되면 임시 테이블을 사용했다는 사실은 알 수 있다.
* 그러나 임시 테이블이 메모리, 디스크 어디서 처리되었는지
* 몇 개의 임시 테이블이 사용되었는지는 알 수 없다.


이런 정보를 확인하려면 MySQL 서버의 상태 변수를 확인하면 된다.
~~~sql
--// 현재 세션의 상태 값 초기화
mysql> FLUSH STATUS;

--// SELECT 문 실행 후
mysql> SELECT first_name, last_name
        FROM employees
        GROUP BY first_name, last_name;

--// 상태 조회 명령을 실행
mysql> SHOW SESSION STATUS LIKE 'Created_tmp%';
~~~

예제의 두 상태 변수에 누적된 값의 의미
* Created_tmp_tables : 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값
  * 디스크, 메모리 구분하지 않고 모두 누적
* Created_tmp_disk_tables : 디스크에 만들어진 내부 임시 테이블의 개수만 누적

## 9.3 고급 최적화
### 9.3.1 옵티마이저 스위치 옵션
optimizer_switch 시스템 변수를 이용

사용할 수 있는 최적화 옵션의 종류

![09-08](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/a5588b44-d3f2-478b-863a-3f792f03bc1a)

![09-09](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/b08843cf-5232-428c-975a-c0733686e567)
* 각각의 스위치 옵션은 on, off, default 중 하나를 선택 가능
* 글로벌 또는 세션별 모두 설정할 수 있다.

글로벌, 세션에 설정
~~~sql
mysql> SET GLOBAL optimizer_switch='index_merge=on, index_merge_union=on, ...';
mysql> SET SESSION optimizer_switch='index_merge=on, index_merge_union=on, ...';
~~~

혹은 현재 쿼리에만 설정
~~~sql
mysql> SELECT /*+SET_VAR(optimizer_switch='condition_fanout_filter=off')*/
        ...
        FROM ...;
~~~

### MRR과 배치 키 액세스(mrr & batched_key_access)
MRR(Multi-Range Read)
* DS-MRR(Disk Sweep MMR)이라고도 함

MySQL 서버에서 지금까지 지원하던 조인 방식
* 드라이빙 테이블의 레코드를 한 건 읽어서 드리븐 테이블의 일치하는 레코드를 찾아서 조인을 수행하는 것
* 네스티드 루프 조인(Nested Loop Join)이라고 함

MySQL 서버의 내부 구조상 조인 처리는 MySQL 엔진이 처리
* 실제 레코드를 검색하고 읽는 부분은 스토리지 엔진이 담당
* 드라이빙 테이블의 레코드를 건별로 드리븐 테이블의 레코드를 찾고 읽는 스토리지 엔진에서는 아무런 최적화를 수행할 수 없다.

단점을 보완하기 위해
* 드라이빙 테이블의 레코드를 읽어 드리븐 테이블과 조인을 즉시 실행하지 않고 버퍼링
* 조인 버퍼에 레코드가 가득 차면 비로소 MySQL 엔진은 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청
* 이렇게 함으로 스토리지 엔진은 읽어야할 레코드들을 데이터 페이지 풀에 정렬된 순서로 접근해서 디스크의 데이터 페이지 읽기를 최소화할 수 있다.

이러한 일기 방식을 MRR이라고 한다.
* BKA(Batched Key Access) 조인 : MMR을 응용해서 실행되는 조인 방식
  * 이는 기본적으로 비활성화
  * 단점이 있기 때문 - 부가적인 정렬 작업이 필요

### 블록 네스티드 루프 조인(block_nested_loop)

네스티드 루프 조인
* MySQL 서버에서 사용되는 대부분의 조인이 이 방식이다.
* 조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 조인 방식
* 중첩된 반복 명령을 사용하는 것처럼 작동
* 레코드를 읽어서 다른 버퍼 공간에 저장하지 않고 즉시 드리븐 테이블의 레코드를 찾아서 반환한다

블록 네스티드 루프 조인
* 조인 버퍼가 사용되는지 여부와 조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인되느냐의 차이
* 조인 알고리즘에서 Block이란 단어가 표시되면 별도의 버퍼가 사용된 것을 의미
  * 실행계획의 "Using Join buffer"라는 문구가 표시됨

조인의 처라
* 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하며 처리
* 즉, 드리븐 테이블은 여러번 읽힌다.
* 옵티마이저는 최대한 드리븐 테이블의 검색이 인덱스를 사용할 수 있게 실행 계획을 수립

그런데 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면.
* 조인 버퍼를 이용하여 처리

### 인덱스 컨디션 푸시다운(index_condition_pushdown)
인덱스 컨디션 푸시다운
* MySQL 5.6 버전부터 도입
* 인덱스를 범위 제한 조건으로 사용하지 못하더라도
* 인덱스에 포함된 칼럼의 조건이 있다면 모두 같이 모아서 스토리지 엔진으로 전달될 수 있게 핸들러 API가 개선됨
* 인덱스를 이용해 최대한 필터링까지 완료해서 꼭 필요한 레코드 1건에 대해서만 테이블 읽기를 수행

실행 계획을 확인하면
* Using index condition이 출력

### 인덱스 확장(use_index_extensions)
* InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션

"세컨더리 인덱스에 자동으로 추가된 프라이머리 키"의 의미
* demp_emp 테이블에서 프라이머리 키 (dept_no, emp_no)
* 세컨더리 인덱스 ix_fromdate는 from_date 칼럼만 포함
* 최종적으로 ix_fromdate는 (from_date, dept_no, emp_no) 조합으로 인덱스를 생성한 것과 흡사하게 작동
* 옵티마이저는 MySQL 서버가 업그레이드 되고 (dept_no, emp_no) 칼럼이 숨어있다는 것을 인지하고 실행 계획을 수립
  * 예전 버전에서는 활용하지 못했다.

조건에 (dept_no, emp_no) 칼럼이 사용되면 사용, 사용하지 않으면 제외

장점
* 프라이머리 키가 세컨더리 인덱스에 포함되어 있으므로 정렬 작업도 인덱스를 활용된다.
* Using Filesort가 표시되지 않는다.

### 인덱스 머지(index_merge)
* 인덱스 머지 실행 계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 처리
* 쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고 그 조건을 만족하는 레코드 건수가 많을 것으로 예상될 때 MySQL 서버는 인덱스 머지 실행 계획을 선택

어떤 방법으로 인덱스를 병합할지에 따른 구분
* index_merge_intersection
* index_merge_sort_union
* index_merge_union

### 인덱스 머지-교집합(index_merge_intersection)
인덱스의 교집합만 반환하여 처리
* 실행 계획에서 Using intersect 메시지 확인 가능

실제로 두 조건을 모두 만족하는 레코드 건수가 적을 때 옵티마이저가 판단하여 두 결과의 교집합만 반환
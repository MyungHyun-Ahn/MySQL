# Chapter 08 인덱스
인덱스는 데이터베이스 쿼리의 성능을 언급하면서 빼놓을 수 없는 부분
* 이번 장에서는 인덱스의 종류 및 특성을 간단히 살펴본다.
* 쿼리 튜닝의 기본이 된다.

## 8.1 디스크 읽기 방식
### 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
하드 디스크 드라이브(HDD)
* 기계식 - 데이터 저장용 플래터(원판)

솔리드 스테이트 드라이브(SSD)
* 전자식 - 플래시 메모리
  * 기계적 회전이 없어 아주 빠르다.
  * 전원이 공급되지 않아도 데이터가 삭제되지 않는다.
* 기존 하드 디스크 드라이브와 같은 인터페이스(SATA나 SAS)를 지원
  * 따라서 기존과 똑같이 사용할 수 있다.

주요 연산 장치의 초당 처리 횟수

![8-01](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/52229c4a-47d1-463e-9af4-b16a85e82d1c)

* 메모리와 디스크의 처리 속도 차이는 10만 배 이상
* SSD와는 1000배 가량 차이
* 요즘에는 대부분 SSD를 채택하여 사용한다.


### 8.1.2 랜덤 I/O와 순차 I/O
랜덤 I/O
* 하드 디스크의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것
* 디스크에 4KB(페이지 크기)의 작은 I/O 요청을 발생


순차 I/O
* 순차 I/O도 이 작업 과정은 같다.
* 헤드의 이동 없이 디스크에 연속되어 있는 여러개의 섹터를 단순히 읽는 것


### 잠깐 운영체제 책의 하드 디스크 드라이브 파트로 넘어와서...

I/O 시간 계산 식

![8-03](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/2713eef1-e2e3-4e5f-b701-3069cb9c04cf)

I/O의 속도(rate, Ri/o)의 계산 식

![8-04](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/12cdd9d8-e49c-40ea-bee8-658ef74101b8)

디스크 드라이브 명세

![8-05](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/4acad9e5-2276-4ce6-9dfa-a194f2e2b43a)
* 두 드라이브들은 상당히 다른 특성을 가지고 있다.
* Cheetah 15K.5 
  * "고성능" 드라이브 시장으로 가능한 빠르게 회전하도록 설계
  * 낮은 탐색 시간
  * 빠른 데이터 전송 속도
* Barracuda
  * "용량" 위주의 시장으로 바이트당 가격이 가장 중요한 측면
  * 드라이브 속도는 낮음
  * 주어진 공간에 가능한 많은 비트를 저장

주어진 드라이브의 값을 이용하여 두 개의 워크로드가 얼마나 잘 동작하는지 계산

Cheetah에서의 랜덤 I/O 시간 계산
* Tseek = 4ms (평균 탐색 시간)
* Trotation = 2ms
  * 평균 회전 지연은 RPM으로 계산
  * 15,000RPM = 250RPS(초당 회전수)
  * 즉, 한번의 회전은 4ms (1000ms = 1s) 즉, 1000ms / 250회 = 4ms
  * 평균적으로 디스크는 반 바퀴 회전을 하므로 2ms
* Ttransfer = 30us (나노초 1000us = 1ms)
  * 전송된 데이터 크기를 최대 전송 속도로 나눈 것
* 따라서 Tseek + Trotation + Ttransfer = 2 + 4 + 0.03 = 6.03ms
* 전송 데이터의 크기를 평균 시간으로 나누면 Ri/o = 0.66MB/s

Barracuda에서의 랜덤 I/O 시간 계산
* 비슷한 방식으로 계산하면
* Ti/o = 13.2ms
* Ri/o = 0.31MB/s

순차 워크로드에서의 시간 계산
* 전송할 데이터의 크기는 100MB라 하자
* Ti/o를 계산하면 각각 800ms와 950ms
* I/O의 속도는 드라이브의 최고 전송 속도인 125MB/s와 105MB/s와 거의 비슷해진다.

즉, 정리하면

![8-06](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/df399582-65a0-477c-9bf5-8c22623cc23b)

이것은 중요한 두 가지 사실을 알려준다.
1. 랜덤 워크로드와 순차 워크로드 간 성능 차이가 크다.
   * cheetah의 경우 200배 이상, Barracuda의 경우 300배 이상
   * 컴퓨터 역사 상 가장 분명한 디자인 팁
2. "성능" 위주의 드라이브와 저사양의 "용량" 위주의 드라이브 간 성능 차이가 상당히 크다.

즉, 데이터를 디스크로 전송하거나 전송받을 때에는 가능하면 순차적인 방식으로 해야한다.
* 불가능하다면 최소한 큰 청크 단위로 데이터를 전송할 수 있는 방법을 생각해야 한다.
* 청크의  크기가 클수록 좋다.


### 다시 MySQL 내용 정리

랜덤 I/O와 순차 I/O의 차이

![8-07](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/12315e8f-43a1-4b9b-bd2b-a3a3f770e60c)

순차 I/O(왼쪽)와 랜덤 I/O(오른쪽)

* 순차 I/O는 3개의 페이지(3x16KB)를 기록하기 위해 1번의 시스템 콜
  * 헤드 1번 이동
* 랜덤 I/O는 3개의 페이지를 기록하기 위해 3번의 시스템 콜
  * 헤드 3번 이동

디스크에 데이터를 읽고 쓰는데 걸리는 시간
* 디스크 헤드를 움직이는 단계에서 결정
* 위에서 계산하며 본 Trotation은 생각보다 컸다.
* 따라서 디스크 헤드를 여러번 움직이는 랜덤 I/O 작업이 부하가 더 크다.

데이터베이스의 대부분의 작업은 작은 데이터를 빈번히 읽고 쓴다.
* MySQL 서버에는 그룹 커밋이나 바이너리 로그 버퍼 또는 InnoDB 로그 버퍼 등의 기능이 내장

랜덤 I/O, 순차 I/O 모두 쓰기를 실행하면 반드시 동기화 작업이 필요
* 순차 I/O이더라도 빈번히 발생한다면 랜덤 I/O와 같이 비효율적인 형태로 처리될 때가 많다.
* 그렇기에 기업용으로 사용하는 데이터베이스 서버에는 캐시 메모리가 장착된 RAID 컨트롤러가 사용된다.
* RAID 컨트롤러의 캐시 메모리는 빈번한 순차 I/O를 효율적으로 처리하도록 변환한다.
* SSD에서도 물론 RAID 컨트롤러는 중요한 역할을 한다.

쿼리를 튜닝한다.
* 랜덤 I/O 자체를 줄이는 것 
  * 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것
* 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 많지 않다.

참고
* 인덱스 레인지 스캔 : 랜덤 I/O
* 풀 테이블 스캔 : 순차 I/O

## 8.2 인덱스란?
인덱스란?
* 책의 마지막에 있는 "찾아보기"로 비유 가능
* 그럼 책의 내용은 데이터 파일
* 책의 "찾아보기"에 있는 페이지 번호 : 저장된 레코드의 주소

DBMS에서 모든 데이터를 검색해서 원하는 결과를 얻으려면 시간이 오래 걸린다.
* 따라서 칼람의 값과 해당 레코드가 저장된 주소를 Key-Value 형태로 삼아 인덱스를 만들어 두는 것
* 책의 "찾아보기"와 인덱스의 공통점 : 정렬
* 인덱스는 SortedList와 같은 형태를 사용하여 항상 정렬된 상태를 유지
  * 이미 정렬되어 있어 원하는 값을 빠르게 찾을 수 있다.
  * 하지만 INSERT, UPDATE, DELETE 문장은 처리가 늦다.
* 데이터 파일은 ArrayList와 같이 저장된 순서대로 정렬 없이 저장

즉 인덱스는 데이터의 저장 성능을 희생하고 읽기 속도를 높이는 기능
* 인덱스의 추가 여부 읽기와 저장의 비율에 따라 결정

인덱스를 역할별로 구분
* 프라이머리 키 (Primary key)
  * 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스
  * 식별자라고 부르기도 함
  * NULL값 허용 X, 중복 허용 X
* 보조 키 (Secondary key)
  * 프라이머리 키를 제외한 모든 인덱스

데이터 저장 방식(알고리즘) 별로 구분
* B-Tree 인덱스
  * 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
  * 위치 기반 검색을 지원하기 위한 R-Tree 인덱스는 B-Tree 인덱스의 응용 알고리즘
* Hash 인덱스
  * 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘
  * 매우 빠른 검색을 지원
  * 값을 변형해서 인덱싱(해시)하므로 전방(Prefix) 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 사용 불가
  * 주로 메모리 기반 데이터베이스에서 많이 사용
* 최근 Fractal-Tree 인덱스, Merge-Tree 인덱스도 사용되기도 함

데이터 중복 여부로 분류
* 유니크 인덱스 - 중복 불가
  * 옵티마이저에게 1건의 레코드를 찾았으면 더 찾지 않아도 됨을 의미
* 유니크하지 않은 인덱스 - 중복 가능

전문 검색용 인덱스나 공간 검색용 인덱스는 뒤에서 알아본다.

## 8.3 B-Tree 인덱스
B-Tree 인덱스
* 인덱싱 알고리즘 중 가장 일반적으로 사용
* 가장 오래되었지만 가장 범용적으로 사용되는 알고리즘
* "B"는 Balanced를 의미

B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태 유지
* 대부분 인덱스는 거의 B-Tree를 사용

### 8.3.1 구조 및 특성
B-Tree는 트리 구조
* 루트 노드(Root node) : 최상위 하나의 노드\
* 리프 노드(Leaf node) : 최하위 노드
* 브랜치 노드(Branch node) : 루트도 아니고 리프도 아닌 중간 노드
* 인덱스와 실제 저장된 데이터는 따로 관리
  * 리프 노드 : 실제 데이터 레코드를 찾아가기 위한 주솟값을 가진다.

![8-08](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/d4b4e2a8-814b-4d71-b436-9a69024c3e5d)
* 인덱스의 키 값은 모두 정렬
* 레코드는 정렬되어 있지 않다.
  * INSERT 순서대로 레코드가 저장된다?
  * 레코드를 전혀 삭제하거나 변경하지 않는다면 맞다.
  * 하지만 삭제된다면 다음의 INSERT는 최대한 빈공간을 재활용하게 된다.

참고
* 대부분의 RDBMS의 데이터 파일에서 레코드는 임의의 순서로 저장
* 하지만 InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장
  * 오라클의 IOT나 MS-SQL의 클러스터 테이블과 같은 구조
* InnoDB 또한 Default로 클러스터링 테이블이 생성
  * 클러스터링 : 비슷한 값을 최대한 모아서 저장하는 방식

인덱스는 테이블의 키 칼럼만 가지고 있다.
* 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.

B-Tree 리프 노드와 테이블 데이터 레코드(MyISAM)

![8-09](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/b33ff53a-e534-4f57-813b-2ce3f99f61e2)
* 레코드 주소 : MyISAM 테이블 생성 옵션에 따라 INSERT 순번 혹은 데이터 파일 내의 위치(Offset)


B-Tree 리프 노드와 테이블 데이터 레코드(InnoDB)

![8-10](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/3885e27e-5805-4f97-b4b3-85859af00d95)
* 프라이머리 키가 ROWID 역할을 한다.

두 스토리지 엔진의 차이점
* MyISAM의 세컨더리 인덱스 : 물리적인 주소
* InnoDB는 프라이머리 키를 주소처럼 사용 : 논리적인 주소

따라서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때 데이터 파일을 바로 찾아가지 못한다.
* 인덱스에 저장된 프라이머리 키 값을 이용하여 프라이머리 키 인덱스를 한 번 더 검색
* 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.
* 2번 읽기 때문에 성능이 떨어져 보이지만 각각 장단점을 가지고 있다.
  * 8.8절 '클러스터링 인덱스'에서 설명


### 8.3.2 B-Tree 인덱스 키 추가 및 삭제
### 8.3.2.1 인덱스 키 추가
B-Tree의 쓰기 작업은 상대적으로 부담스럽다.
* 새로운 키 값이 B-Tree에 저장될 때 스토리지 엔진에 따라 즉시 저장될 수도 아닐 수도 있다.
* B-Tree에 저장될 때 저장될 키 값을 이용해 적절한 위치를 검색해야 한다.
* 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.
* 리프 노드가 꽉 찼다면 리프 노드가 분리(Split)되어야 한다.

인덱스 추가로 인해 INSERT나 UPDATE 문장이 어떤 영향을 받을까?
* 테이블의 칼럼 수, 크기, 인덱스 칼럼의 특성 등을 확인해야 함
* 대략적으로 계산하는 법
  * 추가 작업 비용 1이라 가정
  * 인덱스에 키를 추가하는 작업 비용 1.5라 가정
  * 인덱스가 하나도 없다면 작업 비용 1
  * 3개인 경우 5.5의 비용
* 중요한 것은 비용의 대부분이 메모리와 CPU에서 처리하는 시간이 아니라 디스크로부터 인덱스 페이지를 읽고 쓰기 하는데 걸리는 시간

MyISAM이나 MEMORY 엔진의 경우
* INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 변경한다.

InnoDB의 경우
* 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있다.
* 하지만 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 추가하거나 삭제한다.
* 체인지 버퍼의 대해서는 4.2.10 절 참조

### 8.3.2.2 인덱스 키 삭제
삭제 작업은 간단하다.
* 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료
* 삭제 마킹된 공간은 그대로 방치 또는 재활용
* 이 작업 역시 디스크 I/O가 필요한 작업

MyISAM이나 MEMORY 엔진의 경우
* 즉시 인덱스 키 삭제가 완료된 후 쿼리 실행이 완료

InnoDB의 경우
* 삭제 작업 역시 지연시킬 수 있다.

### 8.3.2.3 인덱스 키 변경
인덱스 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정
* 단순히 키 값만 변경하는 것은 불가능
* 먼저 키 값을 삭제한 후
* 다시 새로운 키 값을 추가하는 형태로 처리된다.
* 앞에서 설명한 추가 / 삭제의 절차대로 진행된다.

InnoDB의 경우
* 체인지 버퍼를 활용하여 지연시킬 수 있다.

### 8.3.2.4 인덱스 키 검색
INSERT, UPDATE, DELETE 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 빠른 탐색을 위해
* 루트 노드부터 최종 리프 노드까지 이동하면서 비교 작업 수행 - 트리 탐색
* SELECT에서 뿐만 아니라 UPDATE, DELETE를 위해 해당 레코드를 먼저 검색해야할 경우에도 사용

B-Tree 인덱스를 이용한 검색은 100% 일치 또는 갚의 앞부분만 일치하는 경우에 사용 가능
* 키 값의 뒷부분만 검색하는 용도로는 사용 불가
* 인덱스 키 값의 변형이 가해진 후 비교되는 경우 사용 불가
  * 변형된 값은 B-Tree 인덱스에 존재하는 값이 아님
  * 함수나 연산을 수행한 결롸로 정렬 혹은 검색 작업은 B-Tree의 장점을 이용할 수 없다.

InnoDB의 경우 더 특별한 의미
* 레코드 잠금이나 넥스트 키 락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현
* 따라서 UPDATE나 DELETE에서 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.
* InnoDB에서는 그만큼 인덱스의 설계가 중요하다.

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
영향을 미치는 요소
* 칼럼의 크기
* 레코드의 건수
* 유니크한 인덱스 키 값의 개수

위 요소에 의해 검색이나 변경 작업의 성능이 영향을 받는다.

### 8.3.3.1 인덱스 키 값의 크기
InnoDB의 페이지(Page) 또는 블록(Block)
* 디스크에 데이터를 저장하는 기본 단위
* 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위
* 버퍼 풀에서 데이터를 버퍼링하는 기본 단위
* 인덱스도 결국 페이지 단위로 관리된다.
  * 루트, 브랜치, 리프 노드를 구분한 기준이 바로 페이지 단위

이진 트리는 각 노드가 자식 노드를 2개만 가지는데 B-Tree가 이진 트리면 인덱스 검색이 상당히 비효율적
* 일반적으로 B-Tree는 자식 노드의 개수가 가변적인 구조

그럼 MySQL의 B-Tree는 자식 노드를 몇 개까지 가질까?
* 인덱스의 페이지 크기와 키 값의 크기에 따라 결정
* InnoDB 페이지 크기는 innodb_page_size 시스템 변수로 4~64KB까지 선택할 수 있다.
  * 기본값 16KB

인덱스 페이지 구성
* 인덱스의 키 16바이트라 가정
* 자식 노드 주소 영역 6바이트~12바이트 - 여기서는 12바이트라 가정

위 인덱스 페이지의 구성을 바탕으로 하나의 인덱스 페이지(16KB)에 몇 개의 키를 저장할 수 있을까?
* 16 * 1024 / (16 + 12) = 585개 저장 가능
* 즉, 자식 노드를 585개 가질 수 있는 B-Tree

키 값이 2배로 늘어나면?
* 16 * 1024 / (32 + 12) = 372개

만약 SELECT 쿼리가 레코드 500개를 읽어야 한다면
* 전자는 인덱스 페이지 한번으로 해결
* 후자는 2번 이상 디스크로부터 읽어야 한다.

즉 인덱스를 구성하는 키 값의 크기가 커지면?
* 디스크 접근 횟수가 늘어나고 그에 따른 속도도 느려진다.
* 인덱스 크기가 커짐을 의미하므로 인덱스를 캐시해두는 캐시 영역은 크기가 제한되어 있어 메모리 효율 또한 떨어진다.

### 8.3.3.2 B-Tree 깊이
깊이는 상당히 중요하지만 직접 제어할 방법은 없다.
* B-Tree의 깊이가 3인 경우
  * 키 값이 16바이트면 최대 2억(585 * 585 * 585) 개의 키 값을 담을 수 있다.
  * 키 값이 32바이트면 최대 5천만(372 * 372 * 372) 개의 키 값을 담을 수 있다.
* B-Tree의 깊이는 몇 번 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제
  * 즉, 인덱스의 크기가 커지면 인덱스 페이지가 담을 수 있는 키 값 수가 줄고, 그에 따른 디스크 읽기가 더 많이 필요할 수도 있다.
* 인덱스의 크기는 가능한 작게 만드는 것이 좋다.

### 8.3.3.3 선택도(기수성)
선택도(Selectivity) 또는 기수성(Cardinality)는 같은 의미
* 모든 인덱스 키 값 가운데 유니크한 값의 수
* 인덱스 키 값 중 중복된 값이 많아질수록 기수성은 낮아지고 선택도 또한 떨어진다.
* 인덱스는 선택도가 높을수록 검색 대상이 줄기 때문에 그만큼 빠르게 처리된다.

참고
* 선택도가 좋지 않더라도 정렬이나 그루핑 같은 작업을 위해 인덱스를 만드는 것이 나을 때도 있다.

예제1
* country라는 칼럼과 city라는 칼럼이 포함된 tb_test 테이블을 예로 든다.
* tb_test의 전체 레코드는 1만 건
* country 칼럼으로만 인덱스가 생성된다.

케이스
* 케이스 A : country 칼럼의 유니크한 값의 개수 10개
* 케이스 B : country 칼럼의 유니크한 값의 개수 1000개

~~~sql
mysql> SELECT *
        FROM tb_test
        WHERE country='KOREA' AND city='SEOUL';
~~~
* MySQL에서는 인덱스의 통계 정보가 관리되기 때문에 city 칼럼의 기수성은 영향이 없다.
* A 케이스의 경우 평균 1000건 조회 가능
* B 케이스의 경우 평균 10건 조회 가능
  * 인덱스 통계 정보로 예측 가능하다.
* A, B 케이스 모두 실제 모든 조건을 만족하는 레코드가 1건?
  * A 케이스는 쓸모없는 레코드 999개를 더 읽으므로 비효율적
* 필요한 만큼만 정확하게 읽으면 최상
  * 현실적으로 모든 조건을 만족하도록 인덱스를 생성하는 것은 불가능
  * B 케이스 정도의 낭비는 무시할 수 있다.

예제2
* 각 국가의 도시를 저장하는 tb_city 테이블
* 1만 건의 레코드가 있다.
* country 칼럼에만 인덱스가 있다.
* 국가와 도시가 중복 저장되어 있지 않다.

~~~sql
mysql> CREATE TABLE tb_city(
          country VARCHAR(10),
          city VARCHAR(10),
          INDEX ix_country(country)
        );
~~~

다음 쿼리를 실행 - 데이터 특성을 두 가지로 나눠 효율성을 살펴본다.
~~~sql
mysql> SELECT *
        FROM tb_test
        WHERE country='KOREA' AND city='SEOUL';
~~~
* country 칼럼의 유니크 값이 10개
  * tb_test 테이블에는 10개의 국가와 도시 정보가 저장
  * 전체 레코드 건 / 유니크 값 수 = 몇 건의 레코드가 일치할지 예측 가능
  * 1000건(10000/10)이 일치할 것이라 예상
  * 그런데 인덱스로 검색된 1000건 가운데 city='SEOUL'인 레코드는 1건으로
  * 999건은 불필요하게 읽은 것
* country 칼럼의 유니크 값이 1000개
  * 10건(10000/1000) 건이 일치할 것이라 예상
  * 위 예와 같이 계산하면 9건은 불필요하게 읽은 것

즉, 인덱스에서 유니크 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향

### 8.3.3.4 읽어야 하는 레코드의 건수
인덱스를 통해 테이블의 레코드를 읽는 것은 바로 테이블의 레코드를 읽는 것보다 높은 비용
* 테이블에 레코드 100만 건, 그중 50만 건을 읽어야 하는 쿼리가 있다 가정
* 이 작업은 전체 테이블을 모두 읽어 필요 없는 50만 건을 버리는 것이 효율적인지
* 인덱스를 통해 필요한 50만 건만 읽는 것이 효율적인지 판단해야 한다.

인덱스를 이용한 읽기의 손익 분기점 판단
* 옵티마이저는 인덱스를 통해 읽는 것보다 테이블에서 직접 읽는 것보다 4~5배 비싼 작업이라 인지
* 만약 인덱스를 통해 읽어야할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘으면 테이블을 모두 읽어 필터링 방식으로 처리하는 것이 효율적

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기
MySQL이 인덱스를 이용하는 대표적인 방법 세 가지를 살펴보자.

### 8.3.4.1 인덱스 레인지 스캔
인덱스의 접근 방법 중 가장 대표적
* 뒤에서 설명할 두 가지 방식 보다 빠른 방식

원래는 인덱스를 통해 한 건만 읽는 경우와 한 건 이상을 읽는 경우를 다른 이름으로 구분
* 이번 절에서는 모두 묶어 "인덱스 레인지 스캔"이라 표현
* 더 상세한 내용은 10장 "실행 계획"에서 다시 언급

쿼리 예제
~~~sql
mysql> SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
~~~

인덱스를 이용한 레인지 스캔 - 실제 인덱스만을 읽는 경우

![8-11](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/a6dbdfc6-eda6-4fa8-aa5c-32f987e82790)

인덱스 레인지 스캔
* 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
* 위 그림에서 보이듯 루트 노드부터 리프 노드까지 찾아들어가야 최종적으로 필요한 레코드의 시작 지점을 알 수 있다.
* 시작할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다.
* 스캔하다 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아 스캔한다.
* 최종적으로 스캔을 멈춰야할 위치에 다다르면 지금까지 읽은 레코드를 반환하고 쿼리를 끝낸다.

인덱스 레인지 스캔을 통한 데이터 레코드 읽기 - 리프 노드를 스캔하며 실제 데이터 파일의 레코드를 읽는 경우

![8-12](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/7073e6f7-1d41-45ff-9cda-06dae9612b12)
* 루트와 브랜치 노드를 이용해 스캔 시작 위치를 검색
* 그 지점부터 필요한 방향(오름차순 또는 내림차순)으로 인덱스를 읽어 나가는 과정
* 중요한 것은 정렬된 상태로 레코드를 가져온다는 것 - 인덱스 자체가 정렬

또 중요한 것
* 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요
* 이때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 당 랜덤 I/O 한 번 발생한다.
* 인덱스로 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업이다.

인덱스 레인지 스캔의 단계를 정리하면
1. 인덱스 탐색(Index seek) : 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다.
2. 인덱스 스캔(Index scan) : 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 쭉 읽는다.
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 최종 레코드를 읽는다.

커버링 인덱스
* 쿼리가 필요로 하는 데이터에 따라 3번 과정이 필요하지 않은 경우
* 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 줄어들고 성능이 빨라진다.

1번과 2번 단계의 작업이 얼마나 수행됐는지 확인하는 방법
~~~sql
mysql> SHOW STATUS LIKE 'Handler_%';
~~~
* Handler_read_key : 1번 단계 실행 횟수
* Handler_read_next, prev : 2번 단계로 읽은 레코드 건수 정순, 역순
* Handler_read_first, last : 인덱스의 첫 번째 레코드와 마지막 레코드를 읽은 횟수
* 3번 단계는 구분하지 않는다.

### 8.3.4.2 인덱스 풀 스캔
인덱스 풀 스캔
* 인덱스의 처음부터 끝까지 모두 읽는 방식
* 대표적으로 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 사용됨

일반적으로 직접 테이블을 처음부터 끝까지 읽는 것보다 인덱스만 읽는 것이 효율적
* 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용됨
* 데이터 레코드까지 모두 읽어야 한다면 절대 이 방식으로 처리되지 않음

인덱스 풀 스캔의 처리 방식

![8-13](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/3f35758c-13a6-4471-9c17-1d8418089455)

* 먼저 인덱스 리프 노드의 제일 앞 혹은 뒤로 이동한 뒤
* 인덱스의 리프 노드를 연결하는 링크드 리스트를 따라 스캔하는 방식을 인덱스 풀 스캔이라고 한다.
* 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다.
* 인덱스에 포함된 칼럼만으로 쿼리를 처리할 수 있는 경우 레코드를 읽을 필요가 없기 때문

참고
* 이 책에서 "인덱스를 사용한다"라고 표현 "인덱스 레인지 스캔" 혹은 "루스 인덱스 스캔"을 사용하는 것을 의미
* 인덱스 풀 스캔은 효율적인 방식은 아니다.

### 8.3.4.3 루스 인덱스 스캔
오라클에서의 "인덱스 스킵 스캔"과 비슷

앞에서 소개한 두 가지 접근 방법은 "타이트(Tight) 인덱스 스캔"으로 분류

루스(Loose) 인덱스 스캔 
* 말 그대로 느슨하게 인덱스를 읽는 것을 의미

![8-14](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/9e21e9a0-48c0-4853-8b42-2080f5d46409)

루스 인덱스 스캔
* 인덱스 레인지 스캔과 비슷하지만
* 중간에 필요치 않은 인덱스 키 값은 SKIP하는 형태로 처리

일반적으로 GROUP BY 또는 집합 함수 가운데 MAX() 또는 MIN() 함수에 대해 최적화를 하는 경우 사용
~~~sql
mysql> SELECT dept_no, MIN(emp_no)
        FROM dept_emp
        WHERE dep_no BETWEEN 'd002' AND 'd004'
        GROUP BY dept_no;
~~~
* WHERE 조건을 만족하는 범위 전체를 스캔할 필요가 없다는 것을 옵티마이저는 안다.
* 따라서 불필요한 부분은 스킵하고 읽도록 최적화 한다.

### 8.3.4.4 인덱스 스킵 스캔
인덱스의 핵심
* 값이 정렬되어 있다.
* 이로 인해 인덱스를 구성하는 칼람의 순서가 매우 중요

employees 테이블에 인덱스를 생성
~~~sql
mysql> ALTER TABLE employees
        ADD INDEX ix_gender_birthdate(gender, birth_date);
~~~

이 인덱스를 사용하려면 WHERE 조건절에 gender 칼럼에 대한 비교 조건이 필수
~~~sql
--// 인덱스를 사용하지 못하는 쿼리
mysql> SELECT * FROM employees WHERE birth_date>='1965-02-01';

--// 인덱스를 사용할 수 있는 쿼리
mysql> SELECT * FROM employees WHERE gender='M' AND birth_date>='1965-02-01';
~~~
* 두 칼럼 모두 비교 조건이 있을 경우에만 인덱스를 효율적으로 사용할 수 있다.
* 첫번쨰의 경우 birth_date 칼럼부터 시작하는 인덱스를 새로 생성해야 한다.

그런데 8.0 부터는 birth_date 칼럼만으로도 인덱스 검색이 가능하게 해주는 기능이 도입

인덱스 스킵 스캔(Index skip scan)
* 루스 인덱스 스캔은 기존에도 있었지만 GROUP BY 작업의 경우에만 적용 가능
* 인덱스 스킵 스캔은 WHERE 절까지 적용 가능

인덱스 스킵 스캔의 처리 과정

![8-15](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/243ecdc8-876e-493f-b516-282d64abb1e2)

인덱스 스킵 스캔의 단점
* WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
  * 쿼리의 실행 계획의 비용과 관련
  * 유니크한 값의 개수가 매우 많다면 옵티마이저가 시작 지점을 검색하는 작업이 많아짐
  * 따라서 성능이 오히려 더 느려질 수 있다.
* 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)
  * 옵티마이저가 개선되면 충분히 해결될 수 있는 부분


### 8.3.5 다중 칼럼(Multi-column) 인덱스
지금까지 살펴본 인덱스는 모두 1개의 칼럼만 포함된 인덱스
* 실제 서비스용 데이터베이스에서는 2개 이상의 칼럼을 포함하는 인덱스가 더 많이 사용된다.


다중 칼럼 인덱스의 구조

![8-16](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/0c7116e0-9592-43ef-bdc2-90140f795ddc)
* 데이터 레코드가 작은 경우 브랜치 노드가 없을 수도 있다.
* 하지만 루트 노드와 리프 노드는 반드시 존재한다.
* 그림에서 보이듯 두 번째 칼럼의 정렬은 첫 번째 칼럼에 의존해 정렬된다.
* 따라서 두 번째 칼럼의 정렬은 첫 번째 칼럼이 일치해야 의미가 있다.

즉 인덱스 내에서 칼럼의 위치가 상당히 중요하다.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

### 8.3.6.1 인덱스의 정렬
MySQL 8.0부터 순서를 혼합한 인덱스 생성 가능
~~~sql
mysql> CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
~~~

### 8.3.6.1.1 인덱스 스캔 방향
인덱스는 항상 오름차순 정렬
* 하지만 최솟값부터 읽으면 오름차순
* 최댓값부터 읽으면 내림차순으로 값을 가져올 수 있다.

~~~sql
mysql> SELECT *
        FROM employees
        ORDER BY first_name DESC
        LIMIT 1;
~~~
* 따라서 위 쿼리는 인덱스를 역순으로 접근해 첫 번째 레코드만 읽으면 된다.

인덱스를 정순으로 읽는 경우와 역순으로 읽는 경우

![8-17](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/4a9ff6e6-6401-4d99-b879-dee03b3f92ba)
* 인덱스 생성 시점에 정렬 방향이 결정되지만
* 그 인덱스를 사용하는 시점에 읽는 방향에 따라 오름차순 내림차순 정렬 효과를 얻을 수 있다.

### 8.3.6.1.2 내림차순 인덱스
간단히 용어를 정리

![8-18](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/c1749f89-4b01-47f2-9b9c-6cb21c1c5a11)
* 오름차순 인덱스(Ascending index) : 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
* 내림차순 인덱스(Descending index) : 큰 값의 인덱스 키가 B-Tree의 오른쪽으로 정렬된 인덱스
* 인덱스 정순 스캔(Forward index scan) : 키에 관계 없이 리프 노드의 왼쪽에서 오른쪽으로 스캔
* 인덱스 역순 스캔(Backward index scan) : 키에 관계 없이 리프 노드의 오른쪽에서 왼쪽으로 스캔

인덱스의 정순 스캔과 역순 스캔
* 역순 스캔이 더 느리다.

내부적으로 느릴 수밖에 없는 이유 두 가지
* 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
* 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

![8-19](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/eb1880ff-8d3a-427a-9976-d70c05720328)
* 레코드가 정렬 순서대로 저장된 것처럼 표시되지만
* 물리적으로 저장이 순서대로 배치되지는 않는다.

다음 쿼리는 어떤 정렬의 인덱스가 좋은 선택일까?

~~~sql
mysql> SELECT * FROM tab
        WHERE userid=?
        ORDER BY score DESC
        LIMIT 10;
~~~
* 이 경우 두 가지 인덱스 모두 적절한 선택이다.
* 하지만 위 쿼리가 빈번하게 실행된다면 내림차순 인덱스가 더 효율적이라고 할 수 있다.

또한 많은 쿼리가 인덱스의 앞쪽 혹은 뒤쪽만 집중적으로 읽어 특정 페이지 잠금이 병목이 될 것으로 예상된다면
* 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목을 완화하는 데 도움이 된다.

### 8.3.7 B-Tree 인덱스의 가용성과 효율성
### 8.3.7.1 비교 조건의 종류와 효율성
동등 비교, 범위 조건인지에 따라 인덱스 칼럼의 활용 형태와 효율이 달라진다.

~~~sql
mysql> SELECT * FROM dept_emp
        WHERE dept_no='d002' AND emp_no >= 10114;
~~~

위 쿼리를 위해 dept_emp 테이블에 칼럼의 순서만 다른 인덱스를 생성했다고 가정
* 어떤 차이가 있을까?

케이스
* A : INDEX(dept_no, emp_no) - 작업 범위 결정 조건
  * dept_no='d002' AND emp_no >= 10114 인 레코드를 찾고
  * dept_no가 d002가 아닐 때까지 쭉 읽기만 하면 된다.
  * 즉, 조건을 만족하는 레코드가 5건일 때, 5번의 비교 작업만 수행한 것
  * 상당히 효율적
* B : INDEX(emp_no, dept_no) - 필터링 조건
  * emp_no >= 10114 AND dept_no='d002'인 레코드를 찾고
  * 모든 레코드에서 dept_no가 d002인지 비교하는 과정을 거쳐야 한다.
  * 최종적으로 5건의 레코드를 가져오긴하지만 7번의 비교 과정을 거쳤다.
  * 다중 칼럼 인덱스의 정렬 방식 때문

![8-20](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/65dcf769-45d9-4f72-ad1d-8782a6d95a54)
* 이처럼 인덱스로 읽은 레코드가 조건에 맞는지 비교하면서 선택하는 작업을 필터링이라고 함


작업 범위 조건은 많을수록 쿼리의 성능을 높인다.

체크 조건은 많으면 오히려 성능을 떨어뜨릴 수 있다.

### 8.3.7.2 인덱스의 가용성
B-Tree 인덱스의 특징
* 왼쪽 값에 기준해서 오른쪽 값이 정렬되어 있다는 것
* 다중 칼럼 인덱스에서도 적용된다.

케이스
* A : INDEX(first_name)
* B : INDEX(dept_no, emp_no)

왼쪽 값을 기준으로 정렬

![8-21](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/bca09562-919a-4e12-aab3-a28098ef70a8)
* 인덱스 키 값의 정렬 특성은 빠른 검색의 전제 조건
* 즉, 하나의 칼럼으로 검색해도 값의 왼쪽 부분이 없으면 인덱스 레인지 스캔이 불가능
  * 다중 칼럼 인덱스에서도 마찬가지

다음 쿼리는 인덱스 레인지 스캔 방식을 이용할 수 없다.
~~~sql
mysql> SELECT * FROM employees WHERE first_name LIKE '%mer';
~~~
* %mer의 왼쪽 부분이 고정되지 않았기 때문에
* 정렬 우선순위가 낮은 뒷부분의 값으로는 B-Tree 인덱스의 효과를 얻을 수 없다.

케이스 B의 인덱스가 지정된 쿼리
~~~sql
mysql> SELECT * FROM dept_emp WHERE emp_no>=10144;
~~~
* 인덱스가 dept_no, emp_no 순서대로 생성되어 있다면, dept_no 조건 없이 emp_no 값으로만 검색하면 인덱스를 효율적으로 사용할 수 없다.
* dept_no 칼럼으로 정렬된 후 emp_no 칼럼으로 정렬되어 있기 때문
* WHERE 뿐만 아니라 GROUP BY, ORDER BY 절에도 마찬가지

### 8.3.7.3 가용성과 효율성 판단
B-Tree 인덱스의 특성상 다음 조건에서는 사용할 수 없다.
* 작업 범위 결정 조건으로 사용할 수 없다는 의미
* 경우에 따라 체크 조건으로는 사용할 수 있다.

NOT-EQUAL로 비교된 경우("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")
* .. WHERE column <> 'N'
* .. WHERE column NOT IN (10, 11, 12)
* .. WHERE column IS NOT NULL

LIKE '%??' 형태로 문자열 패턴이 비교된 경우

스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
* .. WHERE SUBSTRING(column, 1, 1) = 'x'
* .. WHERE DAYOFMONTH(column) = 1

NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
* .. WHERE column = deterministic_function()

데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
* .. WHERE char_column = 10

문자열 데이터 타입의 콜레이션이 다른 경우
* .. WHERE utf8_bin_char_column = euckr_bin_char_column


다른 일반적인 DBMS에서는 NULL 값이 인덱스에 저장되지 않지만 MySQL에서는 저장된다.

다음 WHERE 조건도 작업 범위 결정 조건으로 인덱스를 사용한다.
~~~sql
mysql> .. WHERE column IS NULL .. 
~~~

다중 칼럼으로 만들어진 인덱스는 어떤 경우에 사용될까?
~~~sql
INDEX ix_test(column_1, column_2, ... , column_n)
~~~
* 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
  * column_1 칼럼에 대한 조건이 없는 경우
  * column_1 칼럼의 비교ㅗ 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
* 작업 범위 결정 조건으로 인덱스를 사용하는 경우(i는 2보다 크고 n 보다 작은 임의의 값)
  * column_1 ~ (i-1)까지 동등 비교 형태("=" 또는 "IN")로 비교
  * column_i 칼럼에 대해 다음 연산자 중 하나로 비교
    * 동등 비교("=" 또는 "IN")
    * 크다 작다 형태(">" 또는 "<")
    * LIKE로 좌측 일치 패턴(LIKE '??%')

위 두 가지 조건을 모두 만족하는 쿼리는
* column_1~i 까지 작업 범위 결정 조건으로 사용
* column_(i+1)~n 까지 체크 조건으로 사용
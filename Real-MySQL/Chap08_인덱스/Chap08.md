# Chapter 08 인덱스
인덱스는 데이터베이스 쿼리의 성능을 언급하면서 빼놓을 수 없는 부분
* 이번 장에서는 인덱스의 종류 및 특성을 간단히 살펴본다.
* 쿼리 튜닝의 기본이 된다.

## 8.1 디스크 읽기 방식
### 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
하드 디스크 드라이브(HDD)
* 기계식 - 데이터 저장용 플래터(원판)

솔리드 스테이트 드라이브(SSD)
* 전자식 - 플래시 메모리
  * 기계적 회전이 없어 아주 빠르다.
  * 전원이 공급되지 않아도 데이터가 삭제되지 않는다.
* 기존 하드 디스크 드라이브와 같은 인터페이스(SATA나 SAS)를 지원
  * 따라서 기존과 똑같이 사용할 수 있다.

주요 연산 장치의 초당 처리 횟수

![8-01](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/52229c4a-47d1-463e-9af4-b16a85e82d1c)

* 메모리와 디스크의 처리 속도 차이는 10만 배 이상
* SSD와는 1000배 가량 차이
* 요즘에는 대부분 SSD를 채택하여 사용한다.


### 8.1.2 랜덤 I/O와 순차 I/O
랜덤 I/O
* 하드 디스크의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것
* 디스크에 4KB(페이지 크기)의 작은 I/O 요청을 발생


순차 I/O
* 순차 I/O도 이 작업 과정은 같다.
* 헤드의 이동 없이 디스크에 연속되어 있는 여러개의 섹터를 단순히 읽는 것


### 잠깐 운영체제 책의 하드 디스크 드라이브 파트로 넘어와서...

I/O 시간 계산 식

![8-03](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/2713eef1-e2e3-4e5f-b701-3069cb9c04cf)

I/O의 속도(rate, Ri/o)의 계산 식

![8-04](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/12cdd9d8-e49c-40ea-bee8-658ef74101b8)

디스크 드라이브 명세

![8-05](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/4acad9e5-2276-4ce6-9dfa-a194f2e2b43a)
* 두 드라이브들은 상당히 다른 특성을 가지고 있다.
* Cheetah 15K.5 
  * "고성능" 드라이브 시장으로 가능한 빠르게 회전하도록 설계
  * 낮은 탐색 시간
  * 빠른 데이터 전송 속도
* Barracuda
  * "용량" 위주의 시장으로 바이트당 가격이 가장 중요한 측면
  * 드라이브 속도는 낮음
  * 주어진 공간에 가능한 많은 비트를 저장

주어진 드라이브의 값을 이용하여 두 개의 워크로드가 얼마나 잘 동작하는지 계산

Cheetah에서의 랜덤 I/O 시간 계산
* Tseek = 4ms (평균 탐색 시간)
* Trotation = 2ms
  * 평균 회전 지연은 RPM으로 계산
  * 15,000RPM = 250RPS(초당 회전수)
  * 즉, 한번의 회전은 4ms (1000ms = 1s) 즉, 1000ms / 250회 = 4ms
  * 평균적으로 디스크는 반 바퀴 회전을 하므로 2ms
* Ttransfer = 30us (나노초 1000us = 1ms)
  * 전송된 데이터 크기를 최대 전송 속도로 나눈 것
* 따라서 Tseek + Trotation + Ttransfer = 2 + 4 + 0.03 = 6.03ms
* 전송 데이터의 크기를 평균 시간으로 나누면 Ri/o = 0.66MB/s

Barracuda에서의 랜덤 I/O 시간 계산
* 비슷한 방식으로 계산하면
* Ti/o = 13.2ms
* Ri/o = 0.31MB/s

순차 워크로드에서의 시간 계산
* 전송할 데이터의 크기는 100MB라 하자
* Ti/o를 계산하면 각각 800ms와 950ms
* I/O의 속도는 드라이브의 최고 전송 속도인 125MB/s와 105MB/s와 거의 비슷해진다.

즉, 정리하면

![8-06](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/df399582-65a0-477c-9bf5-8c22623cc23b)

이것은 중요한 두 가지 사실을 알려준다.
1. 랜덤 워크로드와 순차 워크로드 간 성능 차이가 크다.
   * cheetah의 경우 200배 이상, Barracuda의 경우 300배 이상
   * 컴퓨터 역사 상 가장 분명한 디자인 팁
2. "성능" 위주의 드라이브와 저사양의 "용량" 위주의 드라이브 간 성능 차이가 상당히 크다.

즉, 데이터를 디스크로 전송하거나 전송받을 때에는 가능하면 순차적인 방식으로 해야한다.
* 불가능하다면 최소한 큰 청크 단위로 데이터를 전송할 수 있는 방법을 생각해야 한다.
* 청크의  크기가 클수록 좋다.


### 다시 MySQL 내용 정리

랜덤 I/O와 순차 I/O의 차이

![8-07](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/12315e8f-43a1-4b9b-bd2b-a3a3f770e60c)

순차 I/O(왼쪽)와 랜덤 I/O(오른쪽)

* 순차 I/O는 3개의 페이지(3x16KB)를 기록하기 위해 1번의 시스템 콜
  * 헤드 1번 이동
* 랜덤 I/O는 3개의 페이지를 기록하기 위해 3번의 시스템 콜
  * 헤드 3번 이동

디스크에 데이터를 읽고 쓰는데 걸리는 시간
* 디스크 헤드를 움직이는 단계에서 결정
* 위에서 계산하며 본 Trotation은 생각보다 컸다.
* 따라서 디스크 헤드를 여러번 움직이는 랜덤 I/O 작업이 부하가 더 크다.

데이터베이스의 대부분의 작업은 작은 데이터를 빈번히 읽고 쓴다.
* MySQL 서버에는 그룹 커밋이나 바이너리 로그 버퍼 또는 InnoDB 로그 버퍼 등의 기능이 내장

랜덤 I/O, 순차 I/O 모두 쓰기를 실행하면 반드시 동기화 작업이 필요
* 순차 I/O이더라도 빈번히 발생한다면 랜덤 I/O와 같이 비효율적인 형태로 처리될 때가 많다.
* 그렇기에 기업용으로 사용하는 데이터베이스 서버에는 캐시 메모리가 장착된 RAID 컨트롤러가 사용된다.
* RAID 컨트롤러의 캐시 메모리는 빈번한 순차 I/O를 효율적으로 처리하도록 변환한다.
* SSD에서도 물론 RAID 컨트롤러는 중요한 역할을 한다.

쿼리를 튜닝한다.
* 랜덤 I/O 자체를 줄이는 것 
  * 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것
* 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 많지 않다.

참고
* 인덱스 레인지 스캔 : 랜덤 I/O
* 풀 테이블 스캔 : 순차 I/O

## 8.2 인덱스란?
인덱스란?
* 책의 마지막에 있는 "찾아보기"로 비유 가능
* 그럼 책의 내용은 데이터 파일
* 책의 "찾아보기"에 있는 페이지 번호 : 저장된 레코드의 주소

DBMS에서 모든 데이터를 검색해서 원하는 결과를 얻으려면 시간이 오래 걸린다.
* 따라서 칼람의 값과 해당 레코드가 저장된 주소를 Key-Value 형태로 삼아 인덱스를 만들어 두는 것
* 책의 "찾아보기"와 인덱스의 공통점 : 정렬
* 인덱스는 SortedList와 같은 형태를 사용하여 항상 정렬된 상태를 유지
  * 이미 정렬되어 있어 원하는 값을 빠르게 찾을 수 있다.
  * 하지만 INSERT, UPDATE, DELETE 문장은 처리가 늦다.
* 데이터 파일은 ArrayList와 같이 저장된 순서대로 정렬 없이 저장

즉 인덱스는 데이터의 저장 성능을 희생하고 읽기 속도를 높이는 기능
* 인덱스의 추가 여부 읽기와 저장의 비율에 따라 결정

인덱스를 역할별로 구분
* 프라이머리 키 (Primary key)
  * 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스
  * 식별자라고 부르기도 함
  * NULL값 허용 X, 중복 허용 X
* 보조 키 (Secondary key)
  * 프라이머리 키를 제외한 모든 인덱스

데이터 저장 방식(알고리즘) 별로 구분
* B-Tree 인덱스
  * 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
  * 위치 기반 검색을 지원하기 위한 R-Tree 인덱스는 B-Tree 인덱스의 응용 알고리즘
* Hash 인덱스
  * 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘
  * 매우 빠른 검색을 지원
  * 값을 변형해서 인덱싱(해시)하므로 전방(Prefix) 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 사용 불가
  * 주로 메모리 기반 데이터베이스에서 많이 사용
* 최근 Fractal-Tree 인덱스, Merge-Tree 인덱스도 사용되기도 함

데이터 중복 여부로 분류
* 유니크 인덱스 - 중복 불가
  * 옵티마이저에게 1건의 레코드를 찾았으면 더 찾지 않아도 됨을 의미
* 유니크하지 않은 인덱스 - 중복 가능

전문 검색용 인덱스나 공간 검색용 인덱스는 뒤에서 알아본다.

## 8.3 B-Tree 인덱스
B-Tree 인덱스
* 인덱싱 알고리즘 중 가장 일반적으로 사용
* 가장 오래되었지만 가장 범용적으로 사용되는 알고리즘
* "B"는 Balanced를 의미

B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태 유지
* 대부분 인덱스는 거의 B-Tree를 사용

### 8.3.1 구조 및 특성
B-Tree는 트리 구조
* 루트 노드(Root node) : 최상위 하나의 노드\
* 리프 노드(Leaf node) : 최하위 노드
* 브랜치 노드(Branch node) : 루트도 아니고 리프도 아닌 중간 노드
* 인덱스와 실제 저장된 데이터는 따로 관리
  * 리프 노드 : 실제 데이터 레코드를 찾아가기 위한 주솟값을 가진다.

![8-08](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/d4b4e2a8-814b-4d71-b436-9a69024c3e5d)
* 인덱스의 키 값은 모두 정렬
* 레코드는 정렬되어 있지 않다.
  * INSERT 순서대로 레코드가 저장된다?
  * 레코드를 전혀 삭제하거나 변경하지 않는다면 맞다.
  * 하지만 삭제된다면 다음의 INSERT는 최대한 빈공간을 재활용하게 된다.

참고
* 대부분의 RDBMS의 데이터 파일에서 레코드는 임의의 순서로 저장
* 하지만 InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장
  * 오라클의 IOT나 MS-SQL의 클러스터 테이블과 같은 구조
* InnoDB 또한 Default로 클러스터링 테이블이 생성
  * 클러스터링 : 비슷한 값을 최대한 모아서 저장하는 방식

인덱스는 테이블의 키 칼럼만 가지고 있다.
* 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.

B-Tree 리프 노드와 테이블 데이터 레코드(MyISAM)

![8-09](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/b33ff53a-e534-4f57-813b-2ce3f99f61e2)
* 레코드 주소 : MyISAM 테이블 생성 옵션에 따라 INSERT 순번 혹은 데이터 파일 내의 위치(Offset)


B-Tree 리프 노드와 테이블 데이터 레코드(InnoDB)

![8-10](https://github.com/MyungHyun-Ahn/MySQL/assets/78206106/3885e27e-5805-4f97-b4b3-85859af00d95)
* 프라이머리 키가 ROWID 역할을 한다.

두 스토리지 엔진의 차이점
* MyISAM의 세컨더리 인덱스 : 물리적인 주소
* InnoDB는 프라이머리 키를 주소처럼 사용 : 논리적인 주소

따라서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때 데이터 파일을 바로 찾아가지 못한다.
* 인덱스에 저장된 프라이머리 키 값을 이용하여 프라이머리 키 인덱스를 한 번 더 검색
* 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.
* 2번 읽기 때문에 성능이 떨어져 보이지만 각각 장단점을 가지고 있다.
  * 8.8절 '클러스터링 인덱스'에서 설명